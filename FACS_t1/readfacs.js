/*
This is javascript code which parses data files generated by FACS
sorting instrumentation, and then generates a JSON data structure
containing information of interest. It also generates structured data
in a specialized JSON format for use in the d3-timelines plugin.

This code was developed with Node.js, but should run anywhere with a
with few modifications. It looks for all the CSV files in a specified
directory, but that could be changed for whatever file read mechanism
is developed.

d3 is required to get color palates that are used within d3 plugins, to
maintain consistency. moment-timezone is for converting the instrument
timestamp (which contains no timezone information) to a specific timestamp

The command-line form of executing this code is:

node [path to]readfacs.js [data directory] [file prefix] 

If paths are set up to the readfacs.js command, then an absolute path is
not necessary. The data directory is where the CSV files are located.
The file prefix is a name preceding the data files that get generated.
*/

fs = require('fs');
var d3 = require('d3');
var moment = require('moment-timezone');
moment().tz("America/Los_Angeles").format();

var dname = process.argv[2];
var sname = process.argv[3];
console.log(sname,'CSV Parser');

// Parse FACS csv file and generate data structure for specified information
function getHeaderInfo(csvfile) {
  // field values to scan, with name mapping for JSON keys
  let fieldmap = {
    'Report Date': 'startTime',
    'Experiment': 'experiment',
    'Tube': 'tube',
    'Sort Layout': 'barcode',
    'Sort Elapsed Time(hh:mm:ss)': 'elapsedTime'
  };

  let prfname = csvfile.replace(/^.*\//,"");
  let headerInfo = {"csvFile":prfname};
  let facscsv = fs.readFileSync(csvfile, 'utf8');
  let qread = false;  // becomes true when in quadrant section
  let qval = 'Undefined';

  facscsv.split(/\r?\n/).forEach(function(fline){
    let flarr = fline.split(',');

    if (flarr[0] in fieldmap && flarr[1] !== undefined) {
      let prkey = fieldmap[flarr[0]];
      let prval = flarr[1];
      if (prkey == "startTime") {  // make formatted timestamp
        let uldt = prval.replace(/\./g,"-");
        uldt = uldt.replace(" at ","T");
        pacdt = moment.tz(uldt,"America/Los_Angeles");
        prval = pacdt.format('x');
      } else if (prkey == "elapsedTime") { // convert to Epoch milliseconds
        let eltime = prval.split(':')
        let elms = (Number(eltime[0])*3600 +
          Number(eltime[1])*60 + Number(eltime[2]))*1000;
        prval = elms;
      }
      headerInfo[prkey] = prval;
    } else if (flarr[0].startsWith("Sort Layout")) {
      qread = true
    } else if (qread) { // test if Quadrant info is consistent
      let qmatches = fline.match(/(Q\d)/g);
      if (qmatches != undefined) {
        qmatches.forEach(function(qmatch) {
          if (qval == 'Undefined') {
            qval = qmatch;
          } else if (qval != qmatch) {
            console.log("Warning: Quadrant inconsistency")
          }
        })
      }
    }
  });
  headerInfo['quadrant'] = qval;
  return headerInfo;
}

// Form primary data structure, keyed by CSV file
headersByFile = {};
if (! dname.endsWith("/")) {
  dname += "/";
}
fs.readdirSync(dname).forEach(function(fname) {
  if (fname.endsWith(".csv")) {
    let fullpath = dname + fname;
    let fhinfo = getHeaderInfo(fullpath);
    headersByFile[fname] = fhinfo;
  }
});

// Print out JSON-format file
var facsjson = JSON.stringify(headersByFile,null,2);
var fjsfile = sname + '.json';
fs.writeFileSync(fjsfile, facsjson);

// Build key to file mapping for tubes and quadrants
let bcToFiles = {};
let tubeToFiles = {};
let quadToFiles = {};
let headersByTube = {};
Object.keys(headersByFile).forEach(function(cfile) {
  let tube = headersByFile[cfile]["tube"];
  if (!(tube in tubeToFiles)) {
    headersByTube[tube] = [];
    tubeToFiles[tube] = [];
  }
  headersByTube[tube].push(headersByFile[cfile]);
  tubeToFiles[tube].push(cfile);

  let bc = headersByFile[cfile]["barcode"];
  if (!(bc in bcToFiles)) {
    bcToFiles[bc] = [];
  }
  bcToFiles[bc].push(cfile);

  let quad = headersByFile[cfile]["quadrant"];
  if (!(quad in quadToFiles)) {
    quadToFiles[quad] = [];
  }
  quadToFiles[quad].push(cfile);
});

// Build color palate for varying Quadrants
let quadColor = {};
let quadct = 0;
Object.keys(quadToFiles).forEach(function(quad) {
  quadColor[quad] = d3.schemeCategory10[quadct];
  quadct += 1;
});

// Build color palate for varying Tubes (Samples)
let tubeColor = {};
let tubect = 9;
Object.keys(tubeToFiles).forEach(function(tube) {
  tubeColor[tube] = d3.schemeCategory10[tubect];
  tubect -= 1;
});

// d3-timelines settings for Bar Code on vertical axis, coloring by quadrant
let bcstr = "[\n";
Object.keys(bcToFiles).forEach(function(bc) {
  bcstr += '{label: "' + bc + '", times: [';
  bcToFiles[bc].forEach(function(cfile) {
    let tube = headersByFile[cfile]['tube'];
    let stime = Number(headersByFile[cfile]['startTime']);
    let quad = headersByFile[cfile]['quadrant'];
    let etime = stime + Number(headersByFile[cfile]['elapsedTime']);
    let tcolor = tubeColor[tube];
    let dfile = cfile.substr(0,cfile.length-4)
    let infopu = cfile + ": " + bc + '; ' + tube + '; ' + quad;
    bcstr += '{"info": "' + infopu + '", "color":"' + tcolor + '", "label":"' +
      dfile + '", "starting_time": ' + stime + ', "ending_time": ' + etime + '},'
  });
  bcstr += ']},\n';
});
bcstr = bcstr.replace(/,\n$/,"\n]\n");
var bcfile = sname + '_d3tlbc.txt';
fs.writeFileSync(bcfile, bcstr);

// d3-timelines settings for Quadrant on vertical axis, coloring by tube
let quadstr = "[\n";
Object.keys(quadToFiles).forEach(function(quad) {
  quadstr += '{label: "' + quad + '", times: [\n';
  quadToFiles[quad].forEach(function(cfile) {
    let stime = Number(headersByFile[cfile]['startTime']);
    let tube = headersByFile[cfile]['tube'];
    let etime = stime + Number(headersByFile[cfile]['elapsedTime']);
    let tcolor = tubeColor[tube];
    let dfile = cfile.substr(0,cfile.length-4)
    let bc = headersByFile[cfile]["barcode"];
    let infopu = cfile + ": " + bc + '; ' + tube + '; ' + quad;
    quadstr += '{"info": "' + infopu + '", "color":"' + tcolor + '", "label":"' +
      dfile + '", "starting_time": ' + stime + ', "ending_time": ' + etime + '},\n';
  });
  quadstr += ']},\n';
});
quadstr = quadstr.replace(/,\n$/,"\n]\n");
var quadfile = sname + '_d3tlquad.txt';
fs.writeFileSync(quadfile, quadstr);

// d3-timelines settings for Tube on vertical axis, coloring by quadrant
let tubestr = "[\n";
Object.keys(tubeToFiles).forEach(function(tube) {
  tubestr += '{label: "' + tube + '", times: [\n';
  tubeToFiles[tube].forEach(function(cfile) {
    let stime = Number(headersByFile[cfile]['startTime']);
    let quad = headersByFile[cfile]['quadrant'];
    let etime = stime + Number(headersByFile[cfile]['elapsedTime']);
    let tcolor = tubeColor[tube];
    let dfile = cfile.substr(0,cfile.length-4)
    let bc = headersByFile[cfile]["barcode"];
    let infopu = cfile + ": " + bc + '; ' + tube + '; ' + quad;
    tubestr += '{"info": "' + infopu + '", "color":"' + tcolor + '", "label":"' +
      dfile + '", "starting_time": ' + stime + ', "ending_time": ' + etime + '},\n'
  });
  tubestr += ']},\n';
});
tubestr = tubestr.replace(/,\n$/,"\n]\n");
var tubefile = sname + '_d3tltube.txt';
fs.writeFileSync(tubefile, tubestr);

console.log("CSV files processed: ", Object.keys(headersByFile).length);
